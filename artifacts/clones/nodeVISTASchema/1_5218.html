<!doctype html>
<html>
<head>
<title>nodeVISTA (FOIA)</title>
<!--[if IE]>
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/>
<![endif]-->
<meta charset="utf-8"/>
<meta name="application-name" content="FileMan Schema"/>
<meta name="fragment" content="!">
<link rel='stylesheet' href='fmBase.css' type='text/css'>
</head>
<body>
<div id="header">
<h1 id="logo"><a href="index.html">nodeVISTA (FOIA) Schema Browser</a></h1>
</div>
<div id="fmql">
<div class="fmqlResults"><div id="resultsHeader"><h1><a href='index.html'>Files</a> > SQLI_PRIMARY_KEY</h1></div><div id="results"><dl><dt>name</dt><dd>SQLI_PRIMARY_KEY</dd><dt>number</dt><dd>1.5218</dd><dt>location</dt><dd>^DMSQ("P",</dd><dt>description</dt><dd>A chosen set of columns which uniquely identify a table.In the relational model (as in set theory) the columns of a primary keyare not ordered. In SQLI they must be, in order to map to the quasi-hierarchical model of M globals. FileMan subfiles (multiples) have a primary key element for each parentplus one for the subfile. Each contains a pointer to its primary key tableelement (SQLI_TABLE-ELEMENT), a sequence and a column in the local base table (SQL_COLUMN).</dd><dt>Fields</dt><dd><table><thead><tr><th>#</th><th>Name</th><th>Location</th><th>Type</th><th>Details</th><th>Index</th><th>Description</th></tr></thead><tbody><tr><td>.01</td><td>p tbl element(+)</td><td>0;1</td><td>POINTER</td><td><a href="1_5216.html">1.5216</a></td><td>B</td><td>IEN of table element in SQLI_TABLE_ELEMENT</td></tr><tr><td>1</td><td>p column(+)</td><td>0;2</td><td>POINTER</td><td><a href="1_5217.html">1.5217</a></td><td>D</td><td>IEN of column in SQLI_COLUMN corresponding to this primary key</td></tr><tr><td>2</td><td>p sequence(+)</td><td>0;3</td><td>NUMERIC</td><td></td><td></td><td>Sequence number of primary key</td></tr><tr><td>3</td><td>p start at</td><td>0;4</td><td>FREE TEXT</td><td></td><td></td><td>Initial value of key before a $ORDER loop</td></tr><tr><td>4</td><td>p end if</td><td>1;E1,245</td><td>FREE TEXT</td><td></td><td></td><td>M expression in key value, {K}, which, if false, ends the $ORDER loop</td></tr><tr><td>5</td><td>p row count</td><td>0;5</td><td>NUMERIC</td><td></td><td></td><td>Estimated number of rows per record set at this level</td></tr><tr><td>6</td><td>p preselect</td><td>2;E1,245</td><td>FREE TEXT</td><td></td><td></td><td>Code to be executed before selecting this key, before optimization.</td></tr><tr><td>7</td><td>p key format</td><td>0;6</td><td>POINTER</td><td><a href="1_5213.html">1.5213</a></td><td></td><td>Key formats map internal storage values to their value when used as keys.In general, information is lost in the process; they can't be convertedback. This means data must be converted to key format before it can becompared to such a key.</td></tr></tbody></table></dd></dl></div></div><hr><div class="fmqlResults"><p>No REFERENCES reply available to process</p></div>
</div>
<div id="footer"><a href="http://www.caregraf.info">Master FileMan's Data</a>&trade; (c) 2017 <span id="flogo"><a href="http://www.caregraf.info">Caregraf</a></span></div>
</body>
</html>
